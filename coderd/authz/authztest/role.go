package authztest

import (
	. "github.com/coder/coder/coderd/authz"
)

var _ Permission

// Role can print all possible permutations of the given iterators.
type Role struct {
	// returnSize is how many permissions are the returned set for the role
	returnSize int
	// N is the total number of permutations of sets this role will produce.
	N              int
	PermissionSets []Iterator
	// This is kinda werird, but the first scan should not move anything.
	first bool

	buffer []*Permission
}

func NewRole(sets ...Iterable) *Role {
	setInterfaces := make([]Iterator, 0, len(sets))
	var retSize int
	var size int = 1
	for _, s := range sets {
		v := s.Iterator()
		setInterfaces = append(setInterfaces, v)
		retSize += v.ReturnSize()
		// size is the cross product of all Iterator sets
		size *= v.Size()
	}
	return &Role{
		returnSize:     retSize,
		N:              size,
		PermissionSets: setInterfaces,
		buffer:         make([]*Permission, retSize),
	}
}

func (r *Role) Iterator() Iterator {
	return r
}

func (r *Role) ReturnSize() int {
	return r.returnSize
}

func (r *Role) Size() int {
	return r.N
}

// Permissions returns the set of permissions for the role for a given permutation generated by 'Next()'
func (r *Role) Permissions() Set {
	var i int
	for _, ps := range r.PermissionSets {
		i += copy(r.buffer[i:], ps.Permissions())
	}
	return r.buffer
}

func (r *Role) Each(ea func(set Set)) {
	for r.Next() {
		ea(r.Permissions())
	}
}

// Next will grab the next cross-product permutation of all permissions of r.
func (r *Role) Next() bool {
	if !r.first {
		r.first = true
		return true
	}
	for i := range r.PermissionSets {
		if r.PermissionSets[i].Next() {
			break
		} else {
			r.PermissionSets[i].Reset()
			if i == len(r.PermissionSets)-1 {
				return false
			}
		}
	}
	return true
}

func (r *Role) Reset() {
	for _, ps := range r.PermissionSets {
		ps.Reset()
	}
}
